{:binds {
         ;;transforms are like indirection for certain keys,
         ;;so you can flip your mouse buttons etc, but a click can be used for binding
         ;;uniformally
         :transforms {:button.hit/left :click
                      :button.hit/right :alt-click
                      :key.pressed/shift-left :modifer
                      :key.pressed/shift-right :modifier}

         ;;these bindings apply anywhere
         :global {:key.hit/esc :back}

         ;;these bindings apply if the current screen is active
         ;;regardless of any additional context
         :screen {:game {:key.pressed/w {:modifier :cam-up-fast
                                         :else :cam-up}
                         :key.pressed/a {:modifier :cam-left-fast
                                         :else :cam-left}
                         :key.pressed/s {:modifier :cam-down-fast
                                         :else :cam-down}
                         :key.pressed/d {:modifier :cam-right-fast
                                         :else :cam-right}}}

         ;;these bindings apply only if the given context ;;is active
         :context {:game {:click {:modifier :toggle-select
                                  :else [:select
                                         :move]}
                          :alt-click :describe}}}

 :display {:cell-size [32 32]
           :screen-size [1024 768]
           :vsync? true
           :max-fps 0}

 :audio {:volume 1.0
         :music-volume 1.0
         :effect-volume 1.0}

 :world {:things {0 {:name "Fred"
                     :gender :male
                     :race :human}}
         :solid-index {}
         :opaque-index {}
         :space {:eav {}
                 :ave {}}}

 ;; :real, :player, :ai
 :time :ai

 :player {:ids #{0, 1, 2, 3}
          :sorted-ids [0 1 2 3]
          :selected #{0, 1}}

 ;;log contains a bunch of messages
 ;;can subvec to look at a portion of it
 :log ["Fred killed the witch!"]

 ;;context can be resolved to a screen
 ;;and used to determine what input is valid
 ;;use a stack so we can have a 'back button'
 :context '(:casting :inventory :game :menu)

 ;;use state is a map of element id to m
 :ui {:viewport {:camera {:point [552 431]}
                 ;; map of layer to a map of id -> effect
                 ;; effects are things like animations etc
                 :effects {:creature {43 :fire
                                      55 "Parried!"}}}
      :mouse {:point [333 443]
              :cell {:level
                     :point [3 4]}}}

 ;; ai state for things in the world
 :ai {0 {:activity :walking}}

 ;;requests can be made to other subsystems here
 ;;the actions can be interpreted as functions game->game
 ;;or passed out to other modules as IO events
 :actions {;; these are executed/applied at end of frame
           ;; then removed
           :immediate [{:type :play-sound
                        :sound :bla}]
           ;;sorted map of actions to execute
           ;;at the given time
           :at-time {3244 {:type :remove-effect
                           :id 3}}}}